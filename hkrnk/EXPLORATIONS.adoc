== Wise

.Product Defects


Let's visually explore the example matrix step by step, filling out the dynamic programming (DP) table and tracking the largest square size.

=== Given Matrix

[source]
----
1 1 1 1 0
1 1 1 1 1
0 1 1 1 0
1 1 0 0 1
1 1 1 1 1
----

=== Step 1: Initialize the DP Table

Create a DP table of the same size, initialized to `0`:

[source]
----
DP Table:
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
----

=== Step 2: Fill the DP Table

Now we’ll go through the matrix and fill in the DP table according to the rules we discussed:

.1 **First Row and Column**:
   - For the first row and column, copy `1` if the corresponding matrix cell is `1`. Otherwise, it remains `0`.

[source]
----
DP Table after first row and column:
1 1 1 1 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
----

.2 **Filling the rest with the DP Table:**

Now let's process the remaining cells:

- **(1,0)**: `1` → `dp[1][0] = 1`
- **(1,1)**: `1` → `dp[1][1] = min(dp[0][1], dp[1][0], dp[0][0]) + 1 = min(1, 1, 1) + 1 = 2`
- **(1,2)**: `1` → `dp[1][2] = min(dp[0][2], dp[1][1], dp[0][1]) + 1 = min(1, 2, 1) + 1 = 2`
- **(1,3)**: `1` → `dp[1][3] = min(dp[0][3], dp[1][2], dp[0][2]) + 1 = min(0, 2, 1) + 1 = 1`
- **(1,4)**: `0` → `dp[1][4] = 0`

[source]
----
DP Table after processing row 1:
1 1 1 1 0
1 2 2 1 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
----

Continuing in this way:

- **Row 2**:
  - **(2,0)**: `0` → `dp[2][0] = 0`
  - **(2,1)**: `1` → `dp[2][1] = min(dp[1][1], dp[2][0], dp[1][0]) + 1 = min(2, 0, 1) + 1 = 1`
  - **(2,2)**: `1` → `dp[2][2] = min(dp[1][2], dp[2][1], dp[1][1]) + 1 = min(2, 1, 2) + 1 = 2`
  - **(2,3)**: `1` → `dp[2][3] = min(dp[1][3], dp[2][2], dp[1][2]) + 1 = min(1, 2, 2) + 1 = 2`
  - **(2,4)**: `0` → `dp[2][4] = 0`

[source]
----
DP Table after processing row 2:
1 1 1 1 0
1 2 2 1 0
0 1 2 2 0
0 0 0 0 0
0 0 0 0 0
----

- **Row 3**:
  - **(3,0)**: `1` → `dp[3][0] = 1`
  - **(3,1)**: `1` → `dp[3][1] = min(dp[2][1], dp[3][0], dp[2][0]) + 1 = min(1, 1, 0) + 1 = 1`
  - **(3,2)**: `0` → `dp[3][2] = 0`
  - **(3,3)**: `0` → `dp[3][3] = 0`
  - **(3,4)**: `1` → `dp[3][4] = 1`

[source]
----
DP Table after processing row 3:
1 1 1 1 0
1 2 2 1 0
0 1 2 2 0
1 1 0 0 1
0 0 0 0 0
----

- **Row 4**:
  - **(4,0)**: `1` → `dp[4][0] = 1`
  - **(4,1)**: `1` → `dp[4][1] = min(dp[3][1], dp[4][0], dp[3][0]) + 1 = min(1, 1, 1) + 1 = 2`
  - **(4,2)**: `1` → `dp[4][2] = min(dp[3][2], dp[4][1], dp[3][1]) + 1 = min(0, 2, 1) + 1 = 1`
  - **(4,3)**: `1` → `dp[4][3] = min(dp[3][3], dp[4][2], dp[3][2]) + 1 = min(0, 1, 0) + 1 = 1`
  - **(4,4)**: `1` → `dp[4][4] = min(dp[3][4], dp[4][3], dp[3][3]) + 1 = min(1, 1, 0) + 1 = 1

[source]
----
DP Table after processing row 4:
1 1 1 1 0
1 2 2 1 0
0 1 2 2 0
1 1 0 0 1
1 2 1 1 1
----

=== Final Result

Now, we look through the final `dp` table to find the maximum value:

[source]
----
DP Table:
1 1 1 1 0
1 2 2 1 0
0 1 2 2 0
1 1 0 0 1
1 2 1 1 1
----

- The largest square size found is `2`, which appears in several locations (e.g., `dp[1][1]`, `dp[1][2]`, `dp[2][2]`, and `dp[2][3]`).

=== Conclusion

The final answer is that the largest square of non-defective products has a size of **2**.


[source,go]
----
package main

import (
	"fmt"
	"math"
)

// findLargestSquareSize returns the size of the largest square of non-defective products.
func findLargestSquareSize(matrix [][]int) int {
	if len(matrix) == 0 || len(matrix[0]) == 0 {
		return 0
	}

	n := len(matrix)
	m := len(matrix[0])
	dp := make([][]int, n)
	for i := range dp {
		dp[i] = make([]int, m)
	}

	maxSize := 0

	// Fill the dp array
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			if matrix[i][j] == 1 {
				if i == 0 || j == 0 {
					dp[i][j] = 1
				} else {
					dp[i][j] = int(math.Min(float64(dp[i-1][j]), math.Min(float64(dp[i][j-1]), float64(dp[i-1][j-1])))) + 1)
				}
				maxSize = int(math.Max(float64(maxSize), float64(dp[i][j])))
			}
		}
	}

	return maxSize
}

func main() {
	matrix := [][]int{
		{1, 1, 1, 1, 0},
		{1, 1, 1, 1, 1},
		{0, 1, 1, 1, 0},
		{1, 1, 0, 0, 1},
		{1, 1, 1, 1, 1},
	}

	fmt.Println("Largest square size:", findLargestSquareSize(matrix)) // Output: 3
}
----

.API Question
https://jsonmock.hackerrank.com/api/countries/search?region=Europe&name=de[API]

.SQL: Warehouse Accounting System Customer Report
As part of the development of a warehouse accounting system, create a report that lists customers' companies and the total number of active warehouses they have.
Additional information about active warehouses is also required, such as the volume of the smallest warehouse, the volume of the largest warehouse, and the total volume of all warehouses.
The result should have the following columns: name / warehouses / min_volume / max_volume / total_volume.

* name - customer name
* warehouses - the total number of active warehouses for a specific customer
* min_volume - the volume of the smallest active warehouse for a specific customer
* max_volume - the volume of the largest active warehouse for a specific customer
* total_volume - the total volume of all active warehouses for a specific customer
The result should be sorted in ascending order by name.
Note:
* Only active warehouses should be included in the report.

[source,sql]
----
SELECT
    c.name,
    COUNT(w.id) AS warehouses,
    MIN(w.volume) AS min_volume,
    MAX(w.volume) AS max_volume,
    SUM(w.volume) AS total_volume
FROM
    customers c
JOIN
    warehouses w ON c.id = w.customer_id
WHERE
    w.is_active = 1
GROUP BY
    c.name
ORDER BY
    c.name ASC
----
